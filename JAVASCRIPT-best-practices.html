<!DOCTYPE html>
<html lang="pt-br">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<title>Melhores práticas em JS</title>
</head>
<body>

	<script>
		/*Avoid global variables, avoid new, avoid ==, avoid eval()*/

		/*Minimize the use of global variables.
		This includes all data types, objects, and functions.
		Global variables and functions can be overwritten by other scripts.
		Use local variables instead, and learn how to use closures.*/

		/*All variables used in a function should be declared as local variables.
		Local variables must be declared with the var keyword, otherwise they will become global variables.
		Strict mode does not allow undeclared variables.*/

		/*It is a good coding practice to put all declarations at the top of each script or function.
		This will:
		Give cleaner code
		Provide a single place to look for local variables.
		Make it easier to avoid unwanted (implied) global variables.
		Reduce the possibility of unwanted re-declarations.*/
		//Declare no começo.
		var firstName, lastName, price, discount, fullPrice;

		//E use depois.
		firstName = "John";
		lastName = "Doe";

		price = 19.90;
		discount = 0.10;

		fullPrice = price * 100 / discount;

		//This also goes for loop variables.
		//Declare no começo
		var i;

		//use depois
		for(i = 0; i < 5; i++){

		}
		//By default, JavaScript moves all declarations to the top.

		/*It is a good coding practice to initialize variables when you declare them.
		This will:
		Give cleaner code
		Provide a single place to initialize variables
		Avoid undefined values.*/
		//Declare and initiate at the beginning.
		var firstName = "",
		lastName = "",
		price = 0,
		discount = 0,
		fullPrice = 0,
		myArray = [],
		myObject = {};
		//Initializing variables provides an idea of the intended use (and intended data type).

		/*Always treat numbers, strings, or booleans as primitive values. Not as objects.
		Declaring these types as objects, slows down execution speed, and produces nasty side effects.*/
		var x = "John";
		var y = new string("John");
		(x === y); //é falso, porque x é uma string e y é um objeto.

		//ou pior.
		var a = new String("John");
		var b = new String("John");
		(x == y); //é falso porque você não pode comparar objetos.

		/*
		Use {} instead of new Object()
		Use "" instead of new String()
		Use 0 instead of new Number()
		Use false instead of new Boolean()
		Use [] instead of new Array()
		Use /()/ instead of new RegExp()
		Use function (){} instead of new Function()
		*/
		var x1 = {}; //novo objeto
		var x2 = ""; //nova string primitiva
		var x3 = 0; //novo número primitivo
		var x4 = false; //novo boolean primitivo
		var x5 = []; //novo objeto de array
		var x6 = /()/; //novo objeto regexp
		var x7 = function(){}; //new function object

		/*Beware that numbers can accidentally be converted to strings or NaN (Not a Number).
		JavaScript is loosely typed. A variable can contain different data types, and a variable can change its data type*/
		var x = "Hello"; //typeof is String
		x = 5; //changes typeof x to a number

		//When doing mathematical operations, JavaScript can convert numbers to strings.
		var a1 = 5 + 7; //x.valueOf() é 12, typeOf é um número.
		var a2 = 5 + "7"; //x.valueOf() é 57, typeOf é uma String.
		var a3 = "5" + 7; //x.valueOf() é 57, typeOf é uma string.
		var a4 = 5 - 7; //x.valueOf() é -2, typeOf é um número.
		var a5 = 5 - "7"; //x.valueOf() é -2, typeOf é um número.
		var a6 = "5" - 7; //x.valueOf() é -2, typeOf é um número.
		var a7 = 5 - "x"; //x.valueOf() é NaN, typeOf é um número.

		/*Subtracting a string from a string, does not generate an error but returns NaN (Not a Number).*/
		"Hello" - "Dolly" //retorna NaN

		/*The == comparison operator always converts (to matching types) before comparison.
		The === operator forces comparison of values and type.*/
		0 == ""; //true
		1 == "1"; //true
		1 == true; //true

		0 === ""; //false
		1 === "1"; //false
		1 === true; //false

		/*If a function is called with a missing argument, the value of the missing argument is set to undefined.
		Undefined values can break your code. It is a good habit to assign default values to arguments.*/
		function myFunction(x,y){
			if(y === undefined){
				y = 0;
			}
		}

		//ECMAScript 2015 allows default parameters in the function call.
		function (a=1, b=1){ /*function code*/ }

		//Always end your switch statements with a default. Even if you think there is no need for it.

		/*The eval() function is used to run text as code. In almost all cases, it should not be necessary to use it.
		Because it allows arbitrary code to be run, it also represents a security problem.*/
		switch (new Date().getDay()){
			case 0:
				day = "Sunday";
				break;
			case 1:
				day = "Monday";
				break;
			case 2:
				day = "Tuesday";
				break;
			case 3:
				day = "Wednesday";
				break;
			case 4:
				day = "Thursday";
				break;
			case 5:
				day = "Friday";
				break;
			case 6:
				day = "Saturday";
				break;
			default:
				day = "Unknown";
		}
	</script>
</body>
</html>